1. String不可变的原因？
    * String 不可变，StringBuffer 和 StringBuilder 可变。
    * String 不可变，因此是线程安全的。StringBuilder 不是线程安全的；StringBuffer 是线程安全的，使用 synchronized 来同步。
2. Java 中的几种引用类型及其区别是什么？
    * JDK 1.2 开始 Java 提供了四种引用类型，分别是强引用、软引用、弱引用、虚引用，其主要不同点体现在 GC 和使用上面。
        * 强引用：类似 Object obj = new Object() 这样的引用，如果一个对象具有强引用就不会被垃圾回收器回收，即使当前内存空间不足 JVM 也不会回收它，而是抛出 OutOfMemoryError 错误使程序异常终止，如果想中断强引用和某个对象之间的关联，可以显式地将引用所有指向赋值为 null，这样 JVM 就可以在合适的时间回收该对象。
        * 软引用：用来描述一些还有用但是非必须的对象（譬如缓存），其使用 SoftReference 来创建，在使用软引用时如果内存空间足够则软引用就能继续被使用而不会被垃圾回收器回收，只有在内存不足时软引用才会被垃圾回收器回收。
        * 弱引用：用来描述非必须对象的，它的强度比软引用更弱一些，其使用 WeakReference 来创建，具有弱引用的对象拥有的生命周期更短暂，当 JVM 进行垃圾回收时一旦发现弱引用对象则无论当前内存空间是否充足都会将弱引用回收。
        * 虚引用：虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，奖这个虚引用加入引用队列，一个对象是否有虚拟用的存在完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个对象实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
3. Java 创建对象的方式
    * 使用 new 关键字（调用构造方法）
    * 使用 Class 类的 newInstance 方法（调用构造方法）
    * 使用 Constructor 类的 newInstance 方法（调用构造方法）
    * 使用 clone 方法（没有调用构造方法）
    * 使用反序列化（没有调用构造方法）
4. 抽象类和接口有什么区别？
    * 抽象类可以有构造方法；接口中不能有构造方法。
    * 抽象类中可以有普通成员变量或者常量或者静态变量；接口中没有普通成员变量和静态变量，只能是常量（默认修饰符为 publci static final）。
    * 抽象类中可以包含非抽象的普通方法和抽象方法及静态方法；接口中的所有方法必须都是抽象的，不能有非抽象的普通方法和静态方法（默认修饰符为 public abstract）。
    * 抽象类中的抽象方法访问类型可以是 public、protected 的；接口中的抽象方法只能是 public 的（默认修饰符为 public abstract）。
    * 一个子类可以实现多个接口，但只能继承一个抽象类。 
5. Java 重载与重写?
    * 重载规则：必须具有不同的参数列表； 可以有不同的返回类型；可以有不同的访问修饰符；可以抛出不同的异常。
    * 重写规则：参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载；返回类型必须一直与被重写的方法相同，否则不能称其为重写而是重载；访问修饰符的限制一定要大于等于被重写方法的访问修饰符；重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常，譬如父类方法声明了一个检查异常 IOException，在重写这个方法时就不能抛出 Exception，只能抛出 IOException 的子类异常，可以抛出非检查异常。
    * 重载与重写是 Java 多态性的不同表现，重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定），而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。
    * [关于一道题]()
6. Java泛型是如何工作？
    * 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有泛型类型相关的信息
7. 对Java泛型擦除的理解和带来的问题认识？
    * Java 的泛型是伪泛型，因为在编译期间所有的泛型信息都会被擦除掉，譬如 List<Integer> 在运行时仅用一个List来表示。
    * 擦除前的类型检查是针对引用的，用这个引用调用泛型方法就会对这个引用调用的方法进行类型检测而无关它真正引用的对象。
    
### 异常
2. 异常
    * Throwable 是所有异常的父类，它有两个直接子类 Error 和 Exception
    * 其中 Exception 又被继续划分为被检查的异常（checked exception）和运行时的异常（runtime exception，即不受检查的异常）
    * Error 表示系统错误，通常不能预期和恢复（譬如 JVM 崩溃、内存不足等）；被检查的异常（Checked exception）在程序中能预期且要尝试修复（如我们必须捕获 FileNotFoundException 异常并为用户提供有用信息和合适日志来进行调试，Exception 是所有被检查的异常的父类）；
    * RuntimeException 是所有运行时异常的父类。
3.  Error 和 Exception 有什么区别？
    * Error 表示系统级的错误，是 java 运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是 java 虚拟机抛出的。Exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序可以处理的问题。
4. [关于try、catch代码说明](https://github.com/yzrds/note/blob/63eae1bb65516dd29d8893f74d0b918cf656170b/src/com/note/base/ExceptionTest.java)

5. finally代码块一定会执行吗？
    * 只有在 try 里面通过 System.exit(0) 来退出 JVM 的情况下 finally 块中的代码才不会执行，其他 return 等情况都会调用，所以在不终止 JVM 的情况下 finally 中的代码一定会执行。

### 枚举
1. 枚举类比较用== 还是 equals，有啥区别？
    * 枚举 Enum 类的 equals 方法默认实现就是通过 == 来比较的
2. 枚举常量都通过静态代码块进行初始化实例赋值（由于是静态块，所以在类加载期间就初始化了）
3. Java 枚举类可以继承其他类（或实现其他接口）或者被其他类继承吗
    * 枚举类可以实现其他接口但不能继承其他类，因为所有枚举类在编译后的字节码中都继承自 java.lang.Enum（由编译器添加），而 Java 不支持多继承，所以枚举类不可以继承其他类。
4. Java 枚举会比静态常量更消耗内存吗？
    * 会更消耗，一般场景下不仅编译后的字节码会比静态常量多，而且运行时也会比静态常量需要更多的内存，不过这个多取决于场景和枚举的规模等等，不能明确的定论多多少（一般都至少翻倍以上），此外更不能因为多就一刀切的认为静态常量应该优于枚举使用，枚举有自己的特性和场景，优化也不能过度。
### 代码块
1. 