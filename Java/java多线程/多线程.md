1. 多线程的运性结果与代码执行的顺序或者调用的顺序无关

2. 调用多线程，就是分配给cpu分片执行。

3. 线程中 wait()、notify()、notifyAll()、sleep()
    
  wait() 使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。 
  notiyAll() 通知所有等待这个对象控制权的线程继续运行。

4. 可重入锁：自己可以再次获取自己内部的锁，如果不可锁重入的话，锁造成死锁。
  ### 问题：当一个获得锁的线程A，执行过程中调用A.notify()之后，A线程还有可能立马被唤醒，再次执行A线程吗？
  ### 解决：notify一次只随机通知一个线程进行唤醒，sync 关键字，当一个线程因为没有获得锁，会放入一个 lockPool中，当获得锁的线程执行完毕会随机唤醒该池子中的一个线程，因为获得锁的在调用notify之后依旧不在lockPool中，所以A线程不会有立马被执行的可能。